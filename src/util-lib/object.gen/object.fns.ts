// https://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object
// https://mariusschulz.com/blog/the-object-type-in-typescript

import { replaceNullsWithUndefined } from "../setType";

export type GenericObject = Record<string, any>;

export function isEmpty(obj: GenericObject): boolean {
  for (const i in obj) return false;
  return true;
}

/**
 * Checks if any object properties are undefined
 */
export const objPropsDefined = (obj: GenericObject): boolean =>
  Object.keys(obj).every((k) => obj[k] !== undefined);

/**
 * Checks if update has values that are diff to main
 * Ignores partial so if update has undefined props its ok
 * @param main
 * @param update
 */
export function objPropsCompare(
  main: GenericObject,
  update: GenericObject
): boolean {
  return Object.keys(main).every((key) => {
    if (!update.hasOwnProperty(key)) {
      return true;
    }
    if (main[key] === update[key]) {
      return true;
    }
    return false;
  });
}

/**
 * Are they the same
 * @returns boolean
 */
export function shallowCompare(
  obj1: GenericObject,
  obj2: GenericObject
): boolean {
  return (
    Object.keys(obj1).length === Object.keys(obj2).length &&
    Object.keys(obj1).every(
      (key) => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]
    )
  );
}

export function searchObjectByValue<T>(
  haystack: Record<string, T>,
  needle: T
): string | undefined {
  let key = undefined;
  for (const _k in haystack) {
    if (haystack[_k] === needle) {
      key = _k;
      break;
    }
  }
  return key;
}

/** If object value is null returns object with value undefined */
export function removeNullFromObjectValues<T extends GenericObject>(obj1: T) {
  const result = Object.entries(obj1).reduce((acc: any, [k, v]) => {
    if (v === null) {
      acc[k] = undefined;
    } else {
      acc[k] = v;
    }
    return acc;
  }, {});
  return result as replaceNullsWithUndefined<T>;
}

/**
 * STOLEN FROM LODASH Converted to TS
 * The opposite of `mapValue` this method creates an object with the
 * same values as `object` and keys generated by running each own enumerable
 * string keyed property of `object` thru `iteratee`. The iteratee is invoked
 * with three arguments: (value, key, object).
 *
 * @since 3.8.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see mapValue
 * @example
 *
 * mapKey({ 'a': 1, 'b': 2 }, function(value, key) {
 *   return key + value
 * })
 * // => { 'a1': 1, 'b2': 2 }
 */

export function mapKey<T extends GenericObject>(
  object: T,
  iteratee: (value: any, key: string, object: T) => keyof T
): Partial<T> {
  object = Object(object);
  const result: Partial<T> = {};

  Object.keys(object).forEach((key) => {
    const value = object[key];
    const newKey = iteratee(value, key, object);
    result[newKey] = value;
  });
  return result;
}

export default mapKey;
